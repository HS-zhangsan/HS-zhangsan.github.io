[{"title":"测试文件下载","date":"2022-11-28T19:45:52.000Z","date_formatted":{"ll":"Nov 28, 2022","L":"11/28/2022","MM-DD":"11-28"},"updated":"2022-12-09T09:27:52.555Z","content":"这篇文章用来测试文件下载功能\n先来试一下 PDF\n点击下载\nLinux命令行大全\n点击下载：Linux命令行大全\n再来试一下图片\n\n\n\n点击下载\n点击下载\n然后是 MP3 音频\n下载链接：http://zhangsan.works/posts/test_file_download/碧波摇篮曲.mp3/\n碧波摇篮曲\n好听的\n总结\n目前的问题：\n所有的文件（图片、pdf 和 mp3）都可以通过  的形式生成链接，然后进去查看文件和下载，但是并不是点击链接直接下载。另外不知道为什么资源文件夹用不了，而我的封面就是直接用资源文件夹里的图片的，但是文章内所有文件都用不了。\n还有图片，除了上面的通用方法之外，就连普通的引用本地文件都不行了，不管是绝对路径还是相对路径。而我之前在 测试插入图片 这篇文章中已经测试了可以用。\n","thumbnail":"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/654/202211281946795.jpeg","plink":"https://zhangsan.works/posts/test_file_download/"},{"title":"测试插入图片","date":"2022-11-28T13:30:31.000Z","date_formatted":{"ll":"Nov 28, 2022","L":"11/28/2022","MM-DD":"11-28"},"updated":"2022-12-09T09:28:19.749Z","content":"这篇文章用来测试插入图片\n先试一下图床（虽然说肯定没什么问题。。）\n先来一张\n\n再来一张长屏的\n\n再试一下本地图片\n先是绝对路径\n\n然后是相对路径（资源文件夹）\n\n源代码如下：\n\n结论：失败成功\n插入本地图片失败，不知道哪里出了问题，懒得再研究，直接统一用图床。\n更新：插入本地图片只能用绝对路径，相对路径不知道哪里出了问题。嗯，还是直接用图床。\n更新：之前应该是操作失误导致失败的，重新测试了一下又可以了。\n具体地，修改博客根目录的 _config.yml 配置文件，找到 post_asset_folder 修改为 true 开启文章文件夹。然后新建文章的时候在博客根目录用 hexo new post_name 创建，这样就会在文章目录内创建名为 post_name.md 文件的同时创建名为 post_name 的资源文件夹，然后与文章相关的文件在文章内直接引用就可以了。如 post_name 文件夹中有名为 test.jpg 的图片，则引用格式为 ![](test.jpg)。当然，也可以直接使用绝对路径。而我之前把文章标题和文章文件夹名字都改了所以导致错误，这也是这篇文章的日期为什么在后面，因为之前的删了重写了。（如上图所示使用本地图片源代码）\n但是经过测试，使用本地图片的话，由于博客是部署在 GitHub 上的，所以图片加载非常非常慢，所以实际使用还是上传到图床再使用图片链接（我用的腾讯云COS）。\n更新：我去，刚看了一下才发现，我在 测试下载文件功能 这篇文章中使用的封面大小有 50 多 MB，一度让我连图床都上传不上去，传上去之后也加载的贼慢，然后觉得奇怪看了一下图片属性才发现那么大，我说怎么会那么慢。。。\n然后部署的时候，\n\nGitHub最大建议才50MB。。。错了错了，我换还不行么，你说一个图片整这么大这合理吗？\n所以结论是，一般情况下还是可以用本地图片的，虽然会有点慢但是还可以接受。而且都用 hexo 了就图完全本地化，用本地图片也不用担心图床过期什么的。（虽然我还是用图床）\n","thumbnail":"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/654/202211252057512.jpg","plink":"https://zhangsan.works/posts/test_insert_image/"},{"title":"测试评论系统","date":"2022-11-27T14:12:26.000Z","date_formatted":{"ll":"Nov 27, 2022","L":"11/27/2022","MM-DD":"11-27"},"updated":"2022-11-28T19:04:04.863Z","content":"这篇文章用来测试评论系统\n失败！\n","thumbnail":"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/654/202211271413591.png","plink":"https://zhangsan.works/posts/test_comment/"},{"title":"测试插入音视频","date":"2022-11-26T09:05:31.000Z","date_formatted":{"ll":"Nov 26, 2022","L":"11/26/2022","MM-DD":"11-26"},"updated":"2022-11-28T19:01:51.631Z","content":"这篇文章用来测试插入音视频\n先来测试一下 html 直接嵌入\n首先是B站视频\n\n然后是优酷（迪迦奥特曼外传 远古复活的巨人）\n\n再来（德凯奥特曼 日配版 第1集）\n\n接着来（德凯奥特曼 日配版 第18集）\n\n还来（德凯奥特曼 中配版 第18集）\n\n再然后是网易云音乐\n\n最后是qq音乐\nqq音乐竟然不支持外链播放器？？\n然后又试了一下酷狗、咪咕，结果都不支持生成外链播放器，难怪所有人用的都是网易云，是我想当然了。。\n接着测试一下用插件嵌入更多音视频\n用个屁的插件！\n没有需求不要创造需求。\n用插件也简单，下载好插件直接插入就好了，像什么 H5 原生音视频和各种视频播放平台都可以支持。一般也用不到就不再测试了。\n总结\n直接用 html 插入支持的音视频就可以了。插件暂时用不到。\n首先是视频\n视频的话要注意，默认的代码可能看着不太爽，可以自己优化一下改一下参数（比如这篇文章我只改了b站的视频，优酷的没改，所以看着很蠢），比如b站的画质（虽然有 1080p，但是切换不了，最多 720p）、弹幕什么的。\n优酷的视频只能 720p 了，需要会员的东西一律不能用，比如高贵的 1080p，还有需要会员的视频也不能插入，我放个搜出来排在第一的德凯奥特曼竟然都不行！（为什么这逼奥特曼 18 集只有第 18 集要会员，而且只有一集要会员所有的都不能放🤬）\n又试了一下，刚开始提示没有权限不能播放，不知道为什么又可以了，只有要会员的第 19 集不能放（外面显示 18 集，只有第 18 集要会员，进去了之后又变成了 19 集，只有第 19 集要会员放不了。看不懂看不懂。。。）\n还有爱奇艺，压根不支持。\n然后是音频\n目前貌似只有网易云音乐能用，也可以改一下自动播放、播放器大小什么的，然后也就没啥好说的了。。\n以上。\n","thumbnail":"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/654/202211261032402.jpg","plink":"https://zhangsan.works/posts/test_insert_audio&video/"},{"title":"测试嵌入PDF","date":"2022-11-25T20:22:45.000Z","date_formatted":{"ll":"Nov 25, 2022","L":"11/25/2022","MM-DD":"11-25"},"updated":"2022-11-28T18:58:22.728Z","content":"这篇文章用来测试 pdf 嵌入\n注意：移动端不支持（hexo 竟然不支持高亮？？只能加粗了）\n更新：vivo 手机测试，chrome 可以下载但是不能正常显示，夸克浏览器和 vivo 原生浏览器都不能显示。推测 iOS 或者其他安卓手机一样。\n另外，由于本博客部署在 GitHub Page 上，所以 pdf 过大时加载很慢。（可以挂梯子解决）\n首先是比较小的 pdf\n\n\n\t\n    \n\t\n\n\n\n然后是大一点的 pdf\n\n\n\t\n    \n\t\n\n\n\n最后试一下没有目录（书签？）的 pdf\n不好意思，由于现在 markdown 多级标题自动形成目录，所以没有目录的 pdf 还真没找到。。。\n\n\n\t\n    \n\t\n\n\n\n总结：效果还行，可以用\n","thumbnail":"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/654/202211252027510.jpg","plink":"https://zhangsan.works/posts/test_embed_pdf/"},{"title":"Hello World","date":"2022-11-02T11:56:12.553Z","date_formatted":{"ll":"Nov 2, 2022","L":"11/02/2022","MM-DD":"11-02"},"updated":"2022-11-28T18:50:52.474Z","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start\nCreate a new post\n1$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n1$ hexo server\nMore info: Server\nGenerate static files\n1$ hexo generate\nMore info: Generating\nDeploy to remote sites\n1$ hexo deploy\nMore info: Deployment\n","plink":"https://zhangsan.works/posts/hello_world/"},{"title":"往事","date":"2015-12-29T23:52:55.000Z","date_formatted":{"ll":"Dec 29, 2015","L":"12/29/2015","MM-DD":"12-29"},"author":"李大圣","updated":"2022-11-28T18:51:09.297Z","content":"又想起了那个夜晚\n五年前的夜晚\n黑夜，风雪\n大概正好就是这个时间\n也许是九点，十点，\n或者十一点，十二点\n在周围游荡了一圈之后\n我又不自觉得走到了学校门口\n距离村子，距离家\n不过一二百米的学校门口\n四下，\n黑夜中白茫茫的一片\n那是积雪反射的不知何处而来的光\n学校里不复白日的热闹\n从校门口向里边望去\n操场，教室，商店，走廊……\n漆黑一片\n旁边村子的住宅还有几户人家亮着灯\n有些刺眼的光从拉着窗帘的窗户照射出来\n耳旁只有寒风的呼啸\n听不见其他任何声音\n射出光的窗户那边在干什么？\n一家人围着火炉看电视？\n大概吧，\n不然还能是什么呢？\n我没有对窗户那边产生丝毫兴趣\n脑袋里也没有出现任何问题\n我只知道\n在这边听不到窗户那边的声音，\n也许别人只是很安静的干着自己的事情吧\n和我又有什么关系呢？\n不知何时停在了学校门口\n也许走到这里的时候自然的停了吧\n在这样风雪交加的夜晚\n穿着并不算厚的衣服走在外边\n这并不是一件容易的事\n但你只要走就好了\n只要没死就没什么大不了的事\n走是肯定死不了的\n更难的是走着走着停了下来\n我回来这里是干什么来着？\n好像是想随便走走，\n说不定能熬到天亮？\n又好像是因为某种不明的心理原因\n让我在无处可去的时候回到了最熟悉的地方？\n又或者\n这里离家比较近？\n哦对\n想起来了\n在离开最后一个地方的时候\n走在路上思考怎么度过这个夜晚的时候\n想到了学校旁边好像有个麦秆堆来着\n死是肯定不至于的\n这不就想到了办法么？\n冷好像竟然不是那么冷\n但直接睡在室外的环境是不现实的\n会不会在半夜冻死还不好说\n想要睡着首先是个问题\n麦秆是个好东西呀\n虽然外边覆盖了一层雪\n但只要在底下挖出一个洞\n可以想象\n这会是个很舒服的窝\n不知为何\n我又想起了那只被我遗忘的狗\n他死在了一个麦秆堆里\n是冻死的？\n还是饿死的？\n也许都有吧\n总之\n他是因为我而死的\n我把它带了回来\n又把他的存在遗忘了\n突然\n我对这个死过一只狗的的麦秆堆有些抵触\n虽然我清楚\n这不是同一个麦秆堆\n为什么会抵触呢？\n是愧疚在作祟？\n或者只是单纯的嫌弃和厌恶？\n谁知道呢\n轻轻甩甩脑袋\n将这些乱七八糟的想法丢掉\n嘶\n脑袋竟被晃得疼\n是冷的吗？\n还是饿的？\n管他呢\n问题不大\n新的问题又冒了出来\n在这个季节\n在这个天气\n麦秆堆是流浪狗的好去处\n万一这里被流浪狗占据了怎么办？\n赶走就是了\n那狗毛怎么办？\n或者有狗屎呢？\n虽然雪夜没那么黑\n但是想分辨出这些东西还是不那么的容易\n我可以晚上睡在麦秆堆里并不觉自卑羞耻\n白天依旧学习玩耍，该怎样怎样\n我不会刻意掩饰\n也不会主动吹嘘\n没人知道无所谓\n有人知道也不影响\n没人会说什么\n也没人敢说什么\n不会有人因此看低我\n或者还是会有\n那些不认识我的人？\n无所谓\n能这样想的人都是垃圾\n他们再怎么想对我也没影响\n倒是可以预见的\n很多人眼中我的高度再次拔高一截\n也许更多的人\n对我抱有可笑的同情和不解？\n这么一想又太复杂了\n管他呢\n这一个学校的人都认识我\n但我认识的就那么几个\n难不成\n每一个对我有想法的人我都得去认识了解？\n那多累呀\n但是\n睡在麦秆里和身上占了狗屎不一样\n那太丢人了\n而且一旦屎弄到我本身就不算厚的衣服上\n我根本没法也没地方去洗\n更不可能去扔\n那就很麻烦了\n管他呢\n又想的太多了\n得赶快了\n果然一停下来就一点都不想动弹了\n明明还在风雪里边站着呢\n要是有狗的话\n赶走后把麦秆再往外挖一点就行了\n四下转了转\n依旧是那个夜\n没看到好像存在于记忆中的麦秆堆\n我记错了？\n问题不大\n麦秆堆嘛\n多的是\n再找就是了\n从衣兜里掏出手\n使劲搓了搓脸\n又原地活动了一阵\n抖了抖身上的雪\n把本就不多的能量和精力再次消耗大半\n转过身背向学校\n准备再次移动……\n","thumbnail":"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/654/202211022254638.jpg","plink":"https://zhangsan.works/posts/the_past/"},{"title":"about","date":"2020-11-02T23:51:13.000Z","date_formatted":{"ll":"Nov 2, 2020","L":"11/02/2020","MM-DD":"11-02"},"updated":"2023-01-15T03:13:58.199Z","content":"I, ZhangSan, just be an ordinary genius.\nThis is my official account, although I don’t know what to write on it yet. You might as well subscribe first, at least it won’t bother you with useless notifications now and then.\n\nThen, if there is anything you can add me on WeChat. (Indicate the intention, not necessarily agree)\n\n","plink":"https://zhangsan.works/about/"},{"title":"203-移除链表元素","date":"2023-01-23T10:06:07.000Z","date_formatted":{"ll":"Jan 23, 2023","L":"01/23/2023","MM-DD":"01-23"},"updated":"2023-01-23T11:55:50.658Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。\n示例 1：\n\n12输入：head = [1,2,6,3,4,5,6], val = 6输出：[1,2,3,4,5]\n示例 2：\n12输入：head = [], val = 1输出：[]\n示例 3：\n12输入：head = [7,7,7,7], val = 7输出：[]\n提示：\n\n列表中的节点数目在范围 [0, 104] 内\n1 &lt;= Node.val &lt;= 50\n0 &lt;= val &lt;= 50\n\n题解\n解题思路\n\n链表的增删操作比较简单，\n\n删除某个结点只需要将其前一个结点的 next 指向其后一个结点即可。如果使用 c/c++ 千万记得释放内存！\n在某两个结点之间增加新的结点只需将前一个结点的 next 指向要增加的结点，然后将新增加结点的 next 指向后一个结点即可。\n\n\n另外，在遇到链表类题目时，都可以无脑用哑结点。所谓哑结点，即设置一个虚拟头结点（哑结点），让哑结点 dummyHead 的 next 指向原头结点，这样原链表的所有节点就都可以按照统一的方式进行移除了。最后在 return 的时候记得 return dummyHead-&gt;next。哑结点的好处可以参考卡子哥的这篇文章：链表：听说用虚拟头节点会方便很多？，这里不再赘述。\n最后，如果使用 c/c++ 移除链表结点，一定记得清理内存，哪怕在力扣中没有手动在内存中删除这个结点，依然也是可以通过的。其他语言例如Java、Python，都有自己的内存回收机制，就不用自己手动释放了。\n\n代码\n123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     struct ListNode *next; * &#125;; */struct ListNode* removeElements(struct ListNode* head, int val)&#123;    struct ListNode* dummyHead = malloc(sizeof(struct ListNode));    dummyHead-&gt;next = head;    struct ListNode* curr = dummyHead;    while (curr-&gt;next) &#123;        if (curr-&gt;next-&gt;val == val) &#123;            struct ListNode* temp = curr-&gt;next;            curr-&gt;next = curr-&gt;next-&gt;next;            free(temp); //释放已删除的结点        &#125; else &#123;            curr = curr-&gt;next;        &#125;    &#125;        return dummyHead-&gt;next;&#125;\n复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(1)​\n\n注意，链表的增删实际上都是 O(1) 操作，但是操作时需要先从头结点查找到要操作的结点，查找的时间复杂度是 O(n)。\n\n总结\n删除链表节点很基础，能知道逻辑，但是写出来还是磕磕碰碰的。乌鱼子━━(￣ー￣*|||━━\n","plink":"https://zhangsan.works/leetcode/203-移除链表元素/"},{"title":"206-反转链表","date":"2023-01-25T19:07:34.000Z","date_formatted":{"ll":"Jan 25, 2023","L":"01/25/2023","MM-DD":"01-25"},"updated":"2023-01-25T20:07:45.141Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例 1：\n\n12输入：head = [1,2,3,4,5]输出：[5,4,3,2,1]\n示例 2：\n\n12输入：head = [1,2]输出：[2,1]\n示例 3：\n12输入：head = []输出：[]\n提示：\n\n链表中节点的数目范围是 [0, 5000]\n-5000 &lt;= Node.val &lt;= 5000\n\n进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？\n题解\n方法一：双指针法\n\n反转链表比较简单，很容易想到，从前向后遍历链表，然后把每个结点的 next 指向前一个结点就好。\n具体实现中，首先需要两个指针，一个 curr 指针在遍历到每个结点进行操作，一个 prew 指针指向 curr 的前一个结点。其次，由于 curr-&gt;next 指向 prew，导致原来的 curr 的下一个结点失去引用，所以还需要一个指针 temp 用来保存后一个结点。\n\n代码\n123456789101112131415//双指针法struct ListNode* reverseList(struct ListNode* head)&#123;    struct ListNode* curr = head;    struct ListNode* prew = NULL;    while (curr) &#123;        //保存下一个结点        struct ListNode* temp = curr-&gt;next;        //反转结点        curr-&gt;next = prew;        //更新 curr 和 prew 指针        prew = curr;        curr = temp;    &#125;    return prew;&#125;\n方法二：递归法\n\n递归法和双指针法是一样的逻辑，同样是当 curr 为空的时候循环结束，不断将 curr 指向 pre 的过程。具体可以对比双指针法和下面的代码，代码已经详细注释，理解起来应该相当容易。\n\n代码\n从前向后反转指针指向\n123456789101112131415161718192021//递归法（从前向后反转指针指向）struct ListNode* reverse(struct ListNode* curr, struct ListNode* prew) &#123;    if (!curr) &#123;        return prew;    &#125;        struct ListNode* temp = curr-&gt;next;    curr-&gt;next = prew;    //可以与双指针法对比，其实逻辑是一样的，只是用递归实现而已    //下面的代码省去了双指针中更新 curr 和 prew 的过程，直接在递归中引用    return reverse(temp, curr);&#125;struct ListNode* reverseList(struct ListNode* head)&#123;    //这里也是省去了初始化 curr 和 prew 的过程，直接在递归中引用    //下面正文中的代码和注释中的代码是等价的    //struct ListNode* curr = head;    //struct ListNode* prew = NULL;    //return reverse(curr, prew);    return reverse(head, NULL);&#125;\n\n这时候聪明的同学就会说了，上面的双指针法和递归法实质上都是从前往后反转指针指向，那么能不能从后往前反转指针指向呢？\n答案是当然能了，具体代码如下，已经详细注释。\n\n12345678910111213141516//递归法（从后向前反转指针指向）struct ListNode* reverseList(struct ListNode* head)&#123;    //递归结束条件判断    if (!head || !head-&gt;next) &#123;        return head;    &#125;    //调用递归，反转第二个结点后的结点    struct ListNode* newHead = reverseList(head-&gt;next);    //反转头结点与第二个结点    head-&gt;next-&gt;next = head;    //此时 head 是尾结点，尾结点需要指向 NULL    head-&gt;next = NULL;    return newHead;&#125;\n写题解不易，若对你有帮助，点赞评论再走吧。(～￣▽￣)～\n总结\n看了一眼题解直接秒了，用的双指针，递归没做，看了一下之前的题解脑子里过了一遍。\n","plink":"https://zhangsan.works/leetcode/206-反转链表/"},{"title":"209-长度最小的子数组","date":"2023-01-21T10:46:02.000Z","date_formatted":{"ll":"Jan 21, 2023","L":"01/21/2023","MM-DD":"01-21"},"updated":"2023-01-21T11:26:20.657Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n示例1：\n123输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n示例2：\n12输入：target = 4, nums = [1,4,4]输出：1\n示例3：\n12输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0\n题解\n解题思路\n\n我们很容易想到，这道题的暴力解法就是使用两个 for 循环不断寻找符合条件的子数组，这里不再赘述。\n先简单介绍一下滑动窗口，所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。滑动窗口是数组操作中一个重要的方法，本质上还是双指针法的一种。\n本题的关键在于窗口的起始位置如何移动，如以下代码所示：\n\n1234while (sum &gt;= target) &#123;    //若窗口内子数组和大于 target    minLength = fmin(minLength, end - start + 1);   //这里更新最小长度    sum -= nums[start++];   //这里是滑动窗口的妙处所在，不断变更起始位置 start&#125;\n\n可以发现滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将 $O(n^2)$ 的暴力解法降为 $O(n)$。\n\n代码\n12345678910111213int minSubArrayLen(int target, int* nums, int numsSize)&#123;    //这里注意细节，求最小值时要将变量初始化为理论最大值。反之亦然。    int minLength = INT_MAX;    int sum = 0;    //窗口内元素之和    for (int start = 0, end = 0; end &lt; numsSize; end++) &#123;        sum += nums[end];        while (sum &gt;= target) &#123;     //若窗口内子数组和大于 target            minLength = fmin(minLength, end - start + 1);//更新最小子数组长度            sum -= nums[start++];   //这里是滑动窗口的妙处所在，不断变更起始位置 start        &#125;    &#125;    return minLength == INT_MAX ? 0 : minLength;&#125;\n复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(1)​\n\n注意，虽然 for 循环里面还有一个 while 一共两重循环，但是时间复杂度是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是 2 × n 也就是$O(n)$。大部分情况下两重循环还是$O(n^2)$，具体情况具体分析。\n\n总结\n还是一样，一眼滑动窗口，但是就是不知道怎么写，看了之后就会了。\n相关题目\n\n904.水果成篮\n76.最小覆盖子串\n\n","plink":"https://zhangsan.works/leetcode/209-长度最小的子数组/"},{"title":"24-两两交换链表中的结点","date":"2023-01-26T18:10:40.000Z","date_formatted":{"ll":"Jan 26, 2023","L":"01/26/2023","MM-DD":"01-26"},"updated":"2023-01-26T19:05:07.331Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n示例 1：\n\n12输入：head = [1,2,3,4]输出：[2,1,4,3]\n示例 2：\n12输入：head = []输出：[]\n示例 3：\n12输入：head = [1]输出：[1]\n提示：\n\n链表中节点的数目在范围 [0, 100] 内\n0 &lt;= Node.val &lt;= 100\n\n题解\n方法一：迭代\n\n首先，链表类题目无脑用哑结点。\n其次，以 head = [1,2,3,4] 为例，操作前链表为：dummyHead -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; null，交换一对节点的操作分为三步进行：\n\n第一步直接越过下一个节点1，将当前节点 dummyHead 的 next 指向节点2；\n第二步再将节点2的 next 指向节点1；\n第三步将节点1的 next 指向节点3，与原链表重新连接起来。\n\n\n以上三步便可将一对节点交换，操作后链表变为：dummyHead -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4 -&gt; null，之后遍历链表重复进行交换每对数组即可（自己找张纸画一画链表类的问题很简单的）。\n\n代码\n123456789101112131415161718192021222324//迭代版本struct ListNode* swapPairs(struct ListNode* head)&#123;    //设置哑结点，便于后续操作    struct ListNode* dummyHead = malloc(sizeof(struct ListNode));    dummyHead-&gt;next = head;    struct ListNode* curr = dummyHead;    while (curr-&gt;next &amp;&amp; curr-&gt;next-&gt;next) &#123;        //记录临时节点        struct ListNode* temp1 = curr-&gt;next;        struct ListNode* temp2 = curr-&gt;next-&gt;next-&gt;next;        curr-&gt;next = curr-&gt;next-&gt;next;  //第一步        curr-&gt;next-&gt;next = temp1;       //第二步        curr-&gt;next-&gt;next-&gt;next = temp2; //第三步        //注意这里，curr 只移动两位，        //也就是说，移动到下一对要交换的节点之前        //以上述举例为例，curr 只移动到节点2而不是节点3        curr = curr-&gt;next-&gt;next;    &#125;    return dummyHead-&gt;next;&#125;\n复杂度分析\n时间复杂度：O(n)​\n空间复杂度：O(1)​\n方法二：递归\n\n而聪明的同学都知道，递归和循环大多是可以相互替代的，那么这道题呢，也是可以用递归完成的。（PS：一般情况下，建议使用循环而不是递归）\n\n代码\n12345678910111213//递归版本struct ListNode* swapPairs(struct ListNode* head)&#123;    //递归结束条件    if (!head || !head-&gt;next) &#123;        return head;    &#125;    struct ListNode* newHead = head-&gt;next;  //保存下一个节点    head-&gt;next = swapPairs(newHead-&gt;next);  //进入递归    newHead-&gt;next = head;                   //交换节点    return newHead;&#125;\n复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(1)\n总结\n逻辑自己画了画很容易想明白，当然还不够明白，不清晰不透彻，所以没写出来，然后看了一眼题解，豁然开朗，真他妈简单，然后秒了，然后又看了看我之前写的题解，写的是真他妈的好啊，再然后发现之前还用了递归写了，我竟然都没想到（虽然说一般也不会用递归呵呵呵），也懒得再用递归写一遍了，然后只看了看之前的代码，一眼看过去没看懂，然后也懒得看了。。。\n总结：我好像是重新开始一样。。。\n","plink":"https://zhangsan.works/leetcode/24-两两交换链表中的节点/"},{"title":"27-移除元素","date":"2023-01-19T17:52:18.000Z","date_formatted":{"ll":"Jan 19, 2023","L":"01/19/2023","MM-DD":"01-19"},"updated":"2023-01-21T11:25:53.411Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。\n示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n你不需要考虑数组中超出新长度后面的元素。\n题解\n这道题是双指针的经典题目，暴力解法就不再赘述，直接讲双指针的解法。\n\n这是旧版题解\n\n解题思路\n\n首先我们要明确， 数组中的元素不能单独删除，只能覆盖。 （你问为什么？这都不知道你为什么会出现在这里？好吧，原因是 数组的元素在内存地址中是连续的 ）\n回到这道题，移除元素的操作只需要 将其后面的元素依次覆盖前面的 就好。我们很容易想到暴力解法，也就是用两个 for 循环，一个循环遍历数组元素，一个循环更新数组元素。虽然这道题暴力解法也可以过，但是若只是这样我们就不会出现在这里了。(/▽＼)\n（这里我没放暴力的代码，大家可以自己敲出来再进行优化，初学者的话建议不要怕麻烦，没有思路就先写出暴力的解法再考虑能不能优化）\n我们可以使用双指针法，通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作。具体地，遍历数组，快指针和慢指针每次 +1，当位于快指针位置的元素等于要删除的元素时，慢指针停一次，快指针继续递增，每层循环都将快指针位置的元素覆盖至慢指针位置的元素。\n注意以上实现方法并没有改变元素的相对位置。（所以题目的倒数第二句话并没有什么*用）\n\n代码\n12345678910int removeElement(int* nums, int numsSize, int val) &#123;    int fast = 0, slow = 0;    while (fast &lt; numsSize) &#123;        if (nums[fast] != val) &#123;            nums[slow++] = nums[fast];        &#125;        fast++;    &#125;    return slow;&#125;\n复杂度分析\n时间复杂度：O(N)\n空间复杂度：O(1)\n\n\n这是新版题解\n\n解题思路\n\n使用快慢指针，通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n具体地，让两个指针 fast 和 slow 初始都为 0，然后同时向后移动，当遇到 val 时，slow 停下而 fast 继续移动，并在过程中将 nums[fast] 的值赋给 nums[slow] 即可。\n双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。\n\n代码\n12345678910int removeElement(int* nums, int numsSize, int val)&#123;    int fast = 0, slow = 0;    while (fast &lt; numsSize) &#123;        if (nums[fast] != val) &#123;            nums[slow++] = nums[fast];        &#125;        fast++;    &#125;    return slow;&#125;\n复杂度分析\n时间复杂度：O(n)​\n空间复杂度：O(1)​\n总结\n一开始没想到双指针，后面想到了又没写出来。\n总结：长时间不写算法题是这样的，慢慢捡起来就好。\n相关题目\n\n26.删除排序数组中的重复项\n283.移动零\n844.比较含退格的字符串\n977.有序数组的平方\n\n","plink":"https://zhangsan.works/leetcode/27-移除元素/"},{"title":"59-螺旋矩阵II","date":"2023-01-22T09:20:15.000Z","date_formatted":{"ll":"Jan 22, 2023","L":"01/22/2023","MM-DD":"01-22"},"updated":"2023-01-22T11:44:28.923Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n示例 1：\n\n12输入：n = 3输出：[[1,2,3],[8,9,4],[7,6,5]]\n示例 2：\n12输入：n = 1输出：[[1]]\n题解\n解题思路\n\n\n本题并不涉及到什么算法，就是模拟过程，值得注意的一点是，在写代码的过程中一定要遵循循环不变量原则，和 二分查找 中一样，遇到其他情况也是一样。在本题中我统一用左闭右开。\n\n\n具体模拟一下模拟顺时针画矩阵的过程（如图）:\n\n填充上行从左到右\n填充右列从上到下\n填充下行从右到左\n填充左列从下到上\n\n\n\n\n思路很简单，就是从最外圈开始循环，走过一圈后向内圈进一个再继续，直到最后走完。具体看代码，已经详细注释，很容易就能看明白。\n\n\n代码\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */int** generateMatrix(int n, int* returnSize, int** returnColumnSizes)&#123;    //先申请数组并申请空间，其他语言可能不用    int** result = malloc(sizeof(int*) * n);    for (int i = 0; i &lt; n; i++) &#123;        result[i] = malloc(sizeof(int) * n);    &#125;        int loop = n / 2;\t//用来确定循环的圈数    int offset = 1;\t//用来确定每条边遍历的长度    int count = 1;\t//用来给矩阵赋值    int startX = 0, startY = 0;\t//用来确定每个圈开始循环的起始位置    //若 n 为奇数，则需单独给最中间的位置赋值    if (n % 2) &#123;        result[loop][loop] = n * n;    &#125;    //下面就是这道题的核心代码，模拟循环的过程    while (loop--) &#123;        int i = startX;        int j = startY;        //下面四个循环就是模拟每圈的四个边转了一圈，都是左闭右开        //模拟上行从左到右        while (j &lt; n - offset) &#123;            result[i][j++] = count++;        &#125;        //模拟右列从上到下        while (i &lt; n - offset) &#123;            result[i++][j] = count++;        &#125;        //模拟下行从右到左        while (j &gt; startY) &#123;            result[i][j--] = count++;        &#125;        //模拟左列从下到上        while (i &gt; startY) &#123;            result[i--][j] = count++;        &#125;        //每圈结束之后，起始位置各自加一。例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)        startX++;        startY++;        //用来控制每圈每条边的遍历长度，每走一圈就加一。        offset++;    &#125;    *returnSize = n;    *returnColumnSizes = malloc(sizeof(int) * n);    for (int i = 0; i &lt; n; i++) &#123;        (*returnColumnSizes)[i] = n;    &#125;    return result;&#125;\n总结\n还是比较难，也不是一眼就看懂了，之前做过两遍，但还是不熟。\n相关题目\n\n54.螺旋矩阵\n剑指Offer 29.顺时针打印矩阵\n\n","plink":"https://zhangsan.works/leetcode/59-螺旋矩阵II/"},{"title":"704-二分查找","date":"2023-01-17T19:56:44.000Z","date_formatted":{"ll":"Jan 17, 2023","L":"01/17/2023","MM-DD":"01-17"},"updated":"2023-01-21T11:26:11.057Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n示例 1:\n123输入: nums = [-1,0,3,5,9,12], target = 9     输出: 4       解释: 9 出现在 nums 中并且下标为 4     \n示例 2:\n123输入: nums = [-1,0,3,5,9,12], target = 2     输出: -1        解释: 2 不存在 nums 中因此返回 -1        \n提示：\n\n你可以假设 nums 中的所有元素是不重复的。\nn 将在 [1, 10000]之间。\nnums 的每个元素都将在 [-9999, 9999]之间。\n\n题解\n解题思路\n\n二分查找有两个前提，第一是**「有序排列」，第二是「无重复元素」**。当满足以上两点的时候就可以考虑是不是可以使用二分法了。（当然这道题题目已经说了是二分查找）\n二分法的逻辑较简单，需要注意的就是 边界条件 ，例如循环判断条件到底是 left &lt; right 还是 left &lt;= right ？或者 right = middle 还是 right = middle - 1？\n这里需要明确区间的定义，二分法的区间定义一般分为两种，一是左闭右闭 [left, right] ，另一种是左闭右开 [left, right) 。\n以数组 [2, 3, 4, 5, 8, 9] 为例，一共 6 个元素，对应下标为 0-5，当区间定义为左闭右闭时，right 初始化为 5，对应的代码为 left &lt;= right 和 right = middle - 1 ；当区间定义为左闭右开时，right 初始化为 6 （由于元素 nums[6] 无意义，所以边界 6 为开区间） ，对应的代码为 left &lt; right 和 right = middle 。\n两种定义方法选择一种固定使用就好，个人建议左闭右闭，因为右边界有意义，返回结果比较清晰直观。当然，适合自己就好。\n\n代码\n1234567891011121314int search(int* nums, int numsSize, int target)&#123;    int left = 0, right = numsSize - 1;    while (left &lt;= right) &#123;        int middle = left + ((right - left) / 2);        if (nums[middle] &gt; target) &#123;            right = middle - 1;        &#125; else if (nums[middle] &lt; target) &#123;            left = middle + 1;        &#125; else &#123;            return middle;        &#125;    &#125;    return -1;&#125;\n复杂度分析\n时间复杂度：O(logN)\n空间复杂度：O(N)\nPS：若题目要求时间复杂度带 logN ，一般要用到二分法。\n总结\n二分查找比较简单，但是我好久没做题，今天刚上手结果就把二分查找的错误都犯了，具体就是忘了二分查找的关键，即边界条件，由此搞错了循环条件的小于还是小于等于，还有没找到时是等于 middle 还是 middle-1。\n还是不熟悉，太久没做连最基础的二分查找都忘了，一时不知该说什么。\n相关题目\n\n35.搜索插入位置\n34.在排序数组中查找元素的第一个和最后一个位置\n69.x 的平方根\n367.有效的完全平方数\n\n","plink":"https://zhangsan.works/leetcode/704-二分查找/"},{"title":"707-设计链表","date":"2023-01-24T10:00:20.000Z","date_formatted":{"ll":"Jan 24, 2023","L":"01/24/2023","MM-DD":"01-24"},"updated":"2023-01-24T13:06:07.749Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。\n在链表类中实现这些功能：\n\nget(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。\naddAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。\naddAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。\naddAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。\ndeleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。\n\n示例：\n1234567MyLinkedList linkedList = new MyLinkedList();linkedList.addAtHead(1);linkedList.addAtTail(3);linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3linkedList.get(1);            //返回2linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3linkedList.get(1);            //返回3\n提示：\n\n0 &lt;= index, val &lt;= 1000\n请不要使用内置的 LinkedList 库。\nget, addAtHead, addAtTail, addAtIndex 和 deleteAtIndex 的操作次数不超过 2000。\n\n题解\n解题思路\n\n首先还是那句话，链表类题目无脑用虚拟头结点。在这道题中，由于要对用第一个结点进行操作，给出的指针又直接指向第一个结点，所以不用哑结点也没法操作。\n这道题涵盖了链表常见的所有操作，对于理解链表非常有帮助。所有操作的逻辑很简单，如果想不明白不要去硬想，找张纸画一画很容易就理解了。重点是具体的代码实现，可以对着我的代码理解一下，记一记就好了。\n在做这道题的时候我遇到了一个问题，在 deleteAtIndex(index) 操作中，如果我写成 curr-&gt;next = curr-&gt;next-&gt;next ，就会报如下的错误，而改成 curr-&gt;next = temp-&gt;next 就没有问题，也搞不懂为什么。\n\n1error: dereferencing pointer to incomplete type &#x27;struct MyLinkedList&#x27; [solution.c]\n代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//定义链表结点typedef struct &#123;    int val;    struct MyLinkedList* next;&#125; MyLinkedList;//初始化链表MyLinkedList* myLinkedListCreate() &#123;    //这里的头结点是虚拟头结点（哑结点）    MyLinkedList* head = malloc(sizeof(MyLinkedList));    head-&gt;next = NULL;    return head;&#125;//返回第 index 个结点的数值int myLinkedListGet(MyLinkedList* obj, int index) &#123;    MyLinkedList* curr = obj-&gt;next;    for (int i = 0; curr; i++) &#123;        if (i == index) &#123;            return curr-&gt;val;        &#125; else &#123;            curr = curr-&gt;next;        &#125;    &#125;    return -1;&#125;//在链表最前面插入一个节点结点void myLinkedListAddAtHead(MyLinkedList* obj, int val) &#123;    MyLinkedList* head = malloc(sizeof(MyLinkedList));    head-&gt;val = val;    head-&gt;next = obj-&gt;next;    obj-&gt;next = head;&#125;//在链表最后面插入一个结点void myLinkedListAddAtTail(MyLinkedList* obj, int val) &#123;    MyLinkedList* curr = obj;    while (curr-&gt;next) &#123;        curr = curr-&gt;next;    &#125;    MyLinkedList* tail = malloc(sizeof(MyLinkedList));    tail-&gt;val = val;    tail-&gt;next = NULL;    curr-&gt;next = tail;&#125;//在链表第 index 个节点之前插入一个结点void myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) &#123;     MyLinkedList* curr = obj;    for (int i = 0; curr; i++) &#123;        if (i == index) &#123;            MyLinkedList* temp = malloc(sizeof(MyLinkedList));            temp-&gt;val = val;            temp-&gt;next = curr-&gt;next;            curr-&gt;next = temp;        &#125; else &#123;            curr = curr-&gt;next;        &#125;    &#125;&#125;//删除第 index 个结点void myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) &#123;    MyLinkedList* curr = obj;    for (int i = 0; curr; i++) &#123;        if (i == index) &#123;            MyLinkedList* temp = curr-&gt;next;            if (temp) &#123;                //下面这行代码如果改成 curr-&gt;next = curr-&gt;next-&gt;next 就会报错                curr-&gt;next = temp-&gt;next;                free(temp);            &#125;        &#125; else &#123;            curr = curr-&gt;next;        &#125;    &#125;&#125;//删除链表void myLinkedListFree(MyLinkedList* obj) &#123;    while (obj) &#123;        MyLinkedList* temp = obj;        obj = obj-&gt;next;        free(temp);    &#125;&#125;/** * Your MyLinkedList struct will be instantiated and called as such: * MyLinkedList* obj = myLinkedListCreate(); * int param_1 = myLinkedListGet(obj, index);  * myLinkedListAddAtHead(obj, val);  * myLinkedListAddAtTail(obj, val);  * myLinkedListAddAtIndex(obj, index, val);  * myLinkedListDeleteAtIndex(obj, index);  * myLinkedListFree(obj);*/\n总结\n基本都能写出来，但还是磕磕碰碰，免不了要看题解。\n","plink":"https://zhangsan.works/leetcode/707-设计链表/"},{"title":"977-有序数组的平方","date":"2023-01-20T09:05:15.000Z","date_formatted":{"ll":"Jan 20, 2023","L":"01/20/2023","MM-DD":"01-20"},"updated":"2023-01-20T09:31:00.628Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]\n示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]\n题解\n解题思路\n\n我们很容易想到这道题的暴力解法就是给数组每个元素平方后再进行排序，时间复杂度为O(NlogN)。\n然而，由于数组是有序的，即使负数平方后可能会成为最大数，但数组最大值都在数组两端，不是最左边就是最右边，因此可以考虑双指针法了，左右指针分别指向起始位置和终止位置。然后重新使用一个数组 result 用来存放结果，索引 index 指向 result 数组的终止位置。\n\n若 nums[left] * nums[left] &gt; nums[right] * nums[right] ，\n则 result[index--] = nums[left] * nums[left++]\n若 nums[left] * nums[left] &lt;= nums[right] * nums[right] ，\n则 result[index--] = nums[right] * nums[right--]\n\n\n思路清晰明了，想通后不难写出以下代码：\n\n代码\n123456789101112131415161718/** * Note: The returned array must be malloced, assume caller calls free(). */int* sortedSquares(int* nums, int numsSize, int* returnSize)&#123;    int* result = malloc(sizeof(int) * numsSize);    int left = 0, right = numsSize - 1, index = numsSize - 1;    while (left &lt;= right) &#123; //判断条件也可以改成 index &gt;= 0        if (nums[left] * nums[left] &gt; nums[right] * nums[right]) &#123;            result[index--] = nums[left] * nums[left++];        &#125; else &#123;            result[index--] = nums[right] * nums[right--];        &#125;    &#125;    *returnSize = numsSize;    return result;&#125;\n复杂度分析\n时间复杂度：O(N)\n空间复杂度：O(N)\n总结\n想到了双指针但是想出来具体怎么写，看了一眼后也就明白了，就是忘了。\n","plink":"https://zhangsan.works/leetcode/977-有序数组的平方/"},{"title":"leetcode","date":"2023-01-18T00:00:00.000Z","date_formatted":{"ll":"Jan 18, 2023","L":"01/18/2023","MM-DD":"01-18"},"updated":"2023-01-18T03:27:59.820Z","content":"简体中文 ｜ English\n看中文还不够么？。。\n","plink":"https://zhangsan.works/leetcode/index-en/"},{"title":"leetcode","date":"2023-01-18T00:00:00.000Z","date_formatted":{"ll":"Jan 18, 2023","L":"01/18/2023","MM-DD":"01-18"},"updated":"2023-01-26T11:02:31.682Z","content":"简体中文 ｜ English\n*写在前面\n先声明，本人是跟着代码随想录(https://programmercarl.com)刷的，如有雷同，不是巧合。\n然后剩下好多想说的话懒得写了，后面想写了再补上。\n也可以直接在主页或者右下角搜索具体题目。\n\n2023-01-23\n今天翻看之前在力扣上写的题解 203.移除链表元素，发现果然还是被说直接复制代码随想录的，所以我这次开始就说明了。另外，退一步讲，知识这东西学到手上就是自己的，我写的题解也都是看着代码随想录看懂之后再自己记录下来的。正虽然说，你只要跟着别人学的，其他人直接说你是抄的你也没办法，但是，抄这类字眼总会让我伤心，哪怕这只是我矫情。反正我是不承认我抄题解的，读书人的事，那叫抄吗？\n数组\n\n数组理论基础\n二分查找\n移除元素\n有序数组的平方\n长度最小的子数组\n螺旋矩阵II\n数组总结篇\n\n链表\n\n链表理论基础\n移除链表元素\n设计链表\n翻转链表\n两两交换链表中的节点\n删除链表的倒数第N个节点\n链表相交\n环形链表II\n总结篇\n\n哈希表\n字符串\n双指针法\n栈与队列\n二叉树\n回溯算法\n贪心算法\n动态规划\n单调栈\n","plink":"https://zhangsan.works/leetcode/"},{"title":"数组总结篇","date":"2023-01-22T11:36:07.000Z","date_formatted":{"ll":"Jan 22, 2023","L":"01/22/2023","MM-DD":"01-22"},"updated":"2023-01-22T11:41:50.968Z","content":"【目录】\n还是直接搬运卡子哥的总结，原文链接 https://programmercarl.com/数组总结篇.html\n\n数组理论基础\n数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力\n也就是说，想法很简单，但实现起来 可能就不是那么回事了。\n首先要知道数组在内存中的存储方式，这样才能真正理解数组相关的面试题\n数组是存放在连续内存空间上的相同类型数据的集合。\n数组可以方便的通过下标索引的方式获取到下标下对应的数据。\n举一个字符数组的例子，如图所示：\n\n需要两点注意的是\n\n数组下标都是从0开始的。\n数组内存空间的地址是连续的\n\n正是因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。\n例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：\n\n而且大家如果使用C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。\n数组的元素是不能删的，只能覆盖。\n那么二维数组直接上图，大家应该就知道怎么回事了\n\n那么二维数组在内存的空间地址是连续的么？\n我们来举一个Java的例子，例如： int[][] rating = new int[3][4]; ， 这个二维数组在内存空间可不是一个 3*4 的连续地址空间\n看了下图，就应该明白了：\n\n所以Java的二维数组在内存中不是 3\\*4 的连续地址空间，而是四条连续的地址空间组成！\n数组的经典题目\n在面试中，数组是必考的基础数据结构。\n其实数组的题目在思想上一般比较简单的，但是如果想高效，并不容易。\n我们之前一共讲解了四道经典数组题目，每一道题目都代表一个类型，一种思想。\n二分法\n数组：每次遇到二分法，都是一看就会，一写就废\n这道题目呢，考察数组的基本操作，思路很简单，但是通过率在简单题里并不高，不要轻敌。\n可以使用暴力解法，通过这道题目，如果追求更优的算法，建议试一试用二分法，来解决这道题目\n\n暴力解法时间复杂度：O(n)\n二分法时间复杂度：O(logn)\n\n在这道题目中我们讲到了循环不变量原则，只有在循环中坚持对区间的定义，才能清楚的把握循环中的各种细节。\n二分法是算法面试中的常考题，建议通过这道题目，锻炼自己手撕二分的能力。\n双指针法\n\n数组：就移除个元素很难么？\n\n双指针法（快慢指针法）：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n\n暴力解法时间复杂度：O(n^2)\n双指针时间复杂度：O(n)\n\n这道题目迷惑了不少同学，纠结于数组中的元素为什么不能删除，主要是因为以下两点：\n\n数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。\nC++中vector和array的区别一定要弄清楚，vector的底层实现是array，封装后使用更友好。\n\n双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组和链表操作的面试题，都使用双指针法。\n滑动窗口\n\n数组：滑动窗口拯救了你\n\n本题介绍了数组操作中的另一个重要思想：滑动窗口。\n\n暴力解法时间复杂度：O(n^2)\n滑动窗口时间复杂度：O(n)\n\n本题中，主要要理解滑动窗口如何移动 窗口起始位置，达到动态更新窗口大小的，从而得出长度最小的符合条件的长度。\n滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。\n如果没有接触过这一类的方法，很难想到类似的解题思路，滑动窗口方法还是很巧妙的。\n模拟行为\n\n数组：这个循环可以转懵很多人！\n\n模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟，十分考察大家对代码的掌控能力。\n在这道题目中，我们再一次介绍到了循环不变量原则，其实这也是写程序中的重要原则。\n相信大家有遇到过这种情况： 感觉题目的边界调节超多，一波接着一波的判断，找边界，拆了东墙补西墙，好不容易运行通过了，代码写的十分冗余，毫无章法，其实真正解决题目的代码都是简洁的，或者有原则性的，大家可以在这道题目中体会到这一点。\n总结\n\n这个图是 代码随想录知识星球成员：海螺人，所画，总结的非常好，分享给大家。\n从二分法到双指针，从滑动窗口到螺旋矩阵，相信如果大家真的认真做了「代码随想录」每日推荐的题目，定会有所收获。\n推荐的题目即使大家之前做过了，再读一遍文章，也会帮助你提炼出解题的精髓所在。\n","plink":"https://zhangsan.works/leetcode/数组总结篇/"},{"title":"数组理论基础","date":"2023-01-18T09:59:35.000Z","date_formatted":{"ll":"Jan 18, 2023","L":"01/18/2023","MM-DD":"01-18"},"updated":"2023-01-18T11:05:08.157Z","content":"【目录】\n数组比较简单，没什么好说的，为了系统一点也写上，这里直接把 Carl 的搬运过来了，原文链接 https://programmercarl.com/数组理论基础.html\n\n数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力\n也就是说，想法很简单，但实现起来 可能就不是那么回事了。\n首先要知道数组在内存中的存储方式，这样才能真正理解数组相关的面试题\n数组是存放在连续内存空间上的相同类型数据的集合。\n数组可以方便的通过下标索引的方式获取到下标下对应的数据。\n举一个字符数组的例子，如图所示：\n\n需要两点注意的是\n\n数组下标都是从0开始的。\n数组内存空间的地址是连续的\n\n正是因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。\n例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：\n\n而且大家如果使用C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。\n数组的元素是不能删的，只能覆盖。\n那么二维数组直接上图，大家应该就知道怎么回事了\n\n那么二维数组在内存的空间地址是连续的么？\n不同编程语言的内存管理是不一样的，以C++为例，在C++中二维数组是连续分布的。\n我们来做一个实验，C++测试代码如下：\n123456789101112void test_arr() &#123;    int array[2][3] = &#123;\t\t&#123;0, 1, 2&#125;,\t\t&#123;3, 4, 5&#125;    &#125;;    cout &lt;&lt; &amp;array[0][0] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[0][1] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[0][2] &lt;&lt; endl;    cout &lt;&lt; &amp;array[1][0] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[1][1] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[1][2] &lt;&lt; endl;&#125;int main() &#123;    test_arr();&#125;\n测试地址为\n120x7ffee4065820 0x7ffee4065824 0x7ffee40658280x7ffee406582c 0x7ffee4065830 0x7ffee4065834\n注意地址为16进制，可以看出二维数组地址是连续一条线的。\n一些录友可能看不懂内存地址，我就简单介绍一下， 0x7ffee4065820 与 0x7ffee4065824 差了一个4，就是4个字节，因为这是一个int型的数组，所以两个相邻数组元素地址差4个字节。\n0x7ffee4065828 与 0x7ffee406582c 也是差了4个字节，在16进制里8 + 4 = c，c就是12。\n如图：\n\n所以可以看出在C++中二维数组在地址空间上是连续的。\n像Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。\n所以看不到每个元素的地址情况，这里我以Java为例，也做一个实验。\n1234567public static void test_arr() &#123;    int[][] arr = &#123;&#123;1, 2, 3&#125;, &#123;3, 4, 5&#125;, &#123;6, 7, 8&#125;, &#123;9,9,9&#125;&#125;;    System.out.println(arr[0]);    System.out.println(arr[1]);    System.out.println(arr[2]);    System.out.println(arr[3]);&#125;\n输出的地址为：\n1234[I@7852e922[I@4e25154f[I@70dea4e[I@5c647e05\n这里的数值也是16进制，这不是真正的地址，而是经过处理过后的数值了，我们也可以看出，二维数组的每一行头结点的地址是没有规则的，更谈不上连续。\n所以Java的二维数组可能是如下排列的方式：\n\n这里面试中数组相关的理论知识就介绍完了。\n","plink":"https://zhangsan.works/leetcode/数组理论基础/"},{"title":"链表理论基础","date":"2023-01-23T10:06:36.000Z","date_formatted":{"ll":"Jan 23, 2023","L":"01/23/2023","MM-DD":"01-23"},"updated":"2023-01-23T10:09:45.200Z","content":"【目录】\n原链接 https://programmercarl.com/链表理论基础.html\n\n关于链表，你该了解这些！\n什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。\n链表的入口节点称为链表的头结点也就是head。\n如图所示： \n链表的类型\n接下来说一下链表的几种类型:\n单链表\n刚刚说的就是单链表。\n双链表\n单链表中的指针域只能指向节点的下一个节点。\n双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。\n双链表 既可以向前查询也可以向后查询。\n如图所示： \n循环链表\n循环链表，顾名思义，就是链表首尾相连。\n循环链表可以用来解决约瑟夫环问题。\n\n链表的存储方式\n了解完链表的类型，再来说一说链表在内存中的存储方式。\n数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。\n链表是通过指针域的指针链接在内存中各个节点。\n所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。\n如图所示：\n\n这个链表起始节点为2， 终止节点为7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起。\n链表的定义\n接下来说一说链表的定义。\n链表节点的定义，很多同学在面试的时候都写不好。\n这是因为平时在刷leetcode的时候，链表的节点都默认定义好了，直接用就行了，所以同学们都没有注意到链表的节点是如何定义的。\n而在面试的时候，一旦要自己手写链表，就写的错漏百出。\n这里我给出C/C++的定义链表节点方式，如下所示：\n123456// 单链表struct ListNode &#123;    int val;  // 节点上存储的元素    ListNode *next;  // 指向下一个节点的指针    ListNode(int x) : val(x), next(NULL) &#123;&#125;  // 节点的构造函数&#125;;\n有同学说了，我不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。\n但是这个构造函数不会初始化任何成员变量，下面我来举两个例子：\n通过自己定义构造函数初始化节点：\n1ListNode* head = new ListNode(5);\n使用默认构造函数初始化节点：\n12ListNode* head = new ListNode();head-&gt;val = 5;\n所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！\n链表的操作\n删除节点\n删除D节点，如图所示：\n\n只要将C节点的next指针 指向E节点就可以了。\n那有同学说了，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。\n是这样的，所以在C++里最好是再手动释放这个D节点，释放这块内存。\n其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。\n添加节点\n如图所示：\n\n可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。\n但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。\n性能分析\n再把链表的特性和数组的特性进行一个对比，如图所示：\n\n数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。\n链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。\n相信大家已经对链表足够的了解，后面我会讲解关于链表的高频面试题目，我们下期见！\n","plink":"https://zhangsan.works/leetcode/链表理论基础/"},{"title":"timeline","date":"2022-11-28T16:47:42.000Z","date_formatted":{"ll":"Nov 28, 2022","L":"11/28/2022","MM-DD":"11-28"},"updated":"2023-01-18T03:26:07.343Z","content":"\n新增「leetcode」板块，开始在力扣刷题并记录。\n2023-01-18 11:25:00\n\n之前忘了。\n截至今日，博客情况如下：\n基于 hexo &amp; inside，部署在 GitHub Page。\n绑定自定义域名为：https://zhangsan.works/\n完成一系列基础配置。\n完成「嵌入pdf、插入图片、插入音视频、设置永久链接、下载文件功能」测试。\n评论系统测试失败。\n2022-11-28 21:35:56\n往事，不提也罢。\n2015-12-29 23:55:34\n","plink":"https://zhangsan.works/timeline/"}]